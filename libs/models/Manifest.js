"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require('path');
const fs_1 = require('../utils/fs');
const ManifestSchema_1 = require('./ManifestSchema');
/**
 * manifest class could create object to represent target manifest json file
 */
class Manifest {
    /**
     * init and save the manifest as local variable
     */
    constructor(manifestPath) {
        this.manifestPath = manifestPath;
    }
    /**
     * read the transform the manifest file to an object
     */
    read() {
        return __awaiter(this, void 0, void 0, function* () {
            const { manifestPath } = this;
            /**
             * if manifest path is empty, throw errors
             */
            if (!manifestPath) {
                throw `manifest path is not specified`;
            }
            /**
             * standardise the manifest path
             */
            const cliPath = process.cwd();
            const resolveManifestPath = path.resolve(cliPath, manifestPath);
            /**
             *  read the content
             */
            const content = yield fs_1.readFileAsyncPromiseAsJson(resolveManifestPath);
            if (!ManifestSchema_1.default(content)) {
                /**
                 * indent 4 spaces and dump the object as exception
                 */
                debugger;
                throw new Error(JSON.stringify(ManifestSchema_1.default.errors(content), null, 4));
            }
            /**
             * transform it
             */
            this.transform(content.blackList, content.checkList);
            /**
             * create touch markers, this is generated by manifestTransformedList to
             * ensure all manifest settings could be found in target zip file
             */
            this.touchMarkers = Object.keys(this.manifestTransformedList);
            /**
             * supports chainable
             */
            return this;
        });
    }
    /**
     * transform the raw manifest data structure to another form
     * new form will merge all black list and white list together. this allows merging same file pattern so that shorten the validity process
     * @param blackList does not allow to exist in the target content
     * @param checkList must exist at list once in the target content. please use regex if you want to restrict it further
     */
    transform(blackList, checkList) {
        /**
         * new data structure variable
         */
        let list = {};
        /**
         * traverse black list and check list
         */
        [blackList, checkList].forEach((manifestList) => {
            /**
             * differentiate the type
             */
            const type = manifestList === blackList ? 1 /* blackList */ : 0 /* checkList */;
            /**
             * loop the manifest list, the path represents target file path
             */
            for (let path in manifestList) {
                /**
                 * each file path has a list of check list and black list
                 */
                const keywords = manifestList[path];
                /**
                 * standardise all path case
                 */
                const lowCasePath = path.toLowerCase();
                /**
                 * skip if keywords is not an array
                 */
                if (Array.isArray(keywords)) {
                    /**
                     * create a data structure
                     */
                    const newList = keywords.map((keyword) => {
                        return { keyword, type };
                    });
                    /**
                     * merge them to reduce replication
                     *
                     * todo: 测试这里是否能够真正的合并
                     */
                    if (Array.isArray(list[lowCasePath])) {
                        list[lowCasePath] = [...list[lowCasePath], ...newList];
                    }
                    else {
                        list[lowCasePath] = newList;
                    }
                }
            }
        });
        /**
         * save it to local variable
         */
        this.manifestTransformedList = list;
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Manifest;
